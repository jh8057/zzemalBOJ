# 자료구조 및 알고리즘

## 자료구조

1. 선형 구조

- 배열
- 연결리스트
- 스택
- 큐

2. 연결리스트

- 트리 : (포화, 완전) 이진 트리,
  > 우선순위 큐 - 힙 (삽입 삭제 logN) >> 최대힙 , 최소힙 (1927.js)
- 그래프 : 인접행렬(2차원배열) , 인접리스트(연결리스트)
  > 거리가 없으면 인접리스트

## 알고리즘

### 정렬

1. 선택정렬 O(n2) : 가장 작은것을 선택해서 앞으로 보내는 정렬 / 찾는데 n번 , 총 n번
2. 버블정렬 O(n2) : 인접한 2개 비교해서 정렬 / n번 비교 x n 바퀴
3. 삽입정렬 O(n2) : 현재 숫자가 삽입될 위치를 찾아 정렬 / 찾는데 N x 총 N번
4. 병합정렬 : 분할정복 알고리즘 > 주요 브라우저에서 javascript sort NlogN
   4-1. 퀵 정렬 : 피벗 기준으로 분할하며 병합정렬

### 그리디(greedy)

- 가장 좋은 상황만을 선택 , 최적의 상황을 선택했을 떄, 최적의 해가 보장되는 경우에 많이 사용 , 정당성이 확보가 되어야 사용 가능
- 예시 : 거스름돈

### 이진 탐색 (이분 탐색)

- logN
- 파라메트릭 서치 (모수적 서치) : 최적화 문제를 결정 문제로 바꾸어 푸는것 , 이를 통해 logN으로 변경하는 것 (https://sarah950716.tistory.com/16)
  > 만족하는 최소값, 최대값 찾는 문제

* 이진 트리 / 이진 탐색 트리
  (완전)이진 트리: 배열 형태로 쉽게 구현 가능 / 왼쪽 : 2n +1 , 오른쪽 2n+2
  이진 탐색 트리 : 객체 형태로 구현 / new Node() { value, left,right }
  > 이진 트리는 완전 트리일 뿐인거고, 이진 탐색 트리는 탐색을 위해 insert할때 위치를 맞춰 넣어줘야된다.
* 최소값이나 최대값을 삭제할때 배열로 최소힙,최대힙을 이용해서 구현
  > insert, heapifyUP,heapifyDown, delete
* 중간값들 지워야하는 동적인 구조에서는 객체를 통해서 구현

### 백트래킹

- 완전 탐색을 하기 위한 목적으로 사용
- dfs와 다른점은, 단순한 완전 탐색을 하는 것이 아니라, 조건에 따라 유망한 노드로 이동하는 것
- 대표문제 N-queen

### DFS

- 선입후출 , 스택 사용, 인접리스트 많이 사용됨
- 재귀, 트리의 순회, 트리의 최단거리 검색경우
- 마지막에 호출된 노드가 먼저 끝나는 특징
- 노드가 들어오면 방문하지 않은 노드를 찾고 처리 / 방문처리
- 모든 노드를 완전탐색하기 위해 사용
- 1240.js
- graph, visited, distance 등 선언

### BFS

- queue 를 이용해서 구현

### DP

- 메모리를 더 사용해서 시간복잡도를 개선 (dp 테이블 사용)
- (최적 부분 구조 , 반복되는 부분 문제) 두 조건이 만족할 때 사용가능
- 점화식 : 인접한 항으로 현재값을 결정하는 관계식
- 상향식, 하향식

### 최단경로

1. 문제 적용

- 한 지점에서 다른 한 지점까지의 최단경로 > BFS, DFS로도 가능
- 한 지점에서 다른 모든 지점까지의 최단 경로 > 다익스트라
- 모든 지점에서 다른 모든 지점까지의 최단 경로 > 플로이드 워셜

2. 동작 방식

- 최단 거리 테이블은 각 노드에 대한 현재까지의 최단 거리 정보를 가진다.
- 처리 과정에서 더 짧은 경로를 찾으면 더 짧은 경로로 값을 갱신하는 방식

3. 다익스트라 알고리즘

- **특정한 노드**에서 출발하여 다른 모든 노드로 가는 최단 경로 계산
- 음의 간선이 없을 때 사용
- 음의 간선이 있을때는 벨만 포드 사용
- 동작 과정 :
  1. 출발 노드를 설정한다.
  2. 최단 거리 테이블을 초기화한다.
  3. 방문하지 않은 노드 중에서 **최단 거리가 가장 짧은 노드**를 선택한다.
  4. 해당 노드를 거쳐서 다른 노드로 가는 비용을 계산하여 최단 거리 테이블을 갱신한다.
     > 최단 거리 테이블을 직접 갱신하지 않고 우선순위 큐에 삽입하는 방식으로 사용할 수 도 있다.
  5. 위 과정에서 3번과 4번을 반복한다.
- 최단 거리를 선택하고 계산하므로 "그리디" 알고리즘에 속함
- 방문하지 않은 가장 비용이 적은 노드를 선택해 임의의 과정을 반복
- 한번 처리된 노드의 최단거리는 고정되어 더이상 바뀌지 않는다.
- 우선순위 큐를 이용
  > js에서는 우선순위 큐 대신 큐에 객체를 저장하고, 계산후 최단거리 노드만 다시 queue에 저장하는 식으로 구현 가능 (https://han-joon-hyeok.github.io/posts/dijkstra-algorithm/)
- 큐 사용 > 우선순위로 큐 뽑음 > 탐색 끝날때까지 진행
- 음수 순환이 있는 경우 사용할 수 없음

4. 플로이드 워셜

- **모든 노드**에서 출발하여 다른 모든 노드로 가는 최단 경로 계산
- 각 단계마다 특정 노드 K를 거쳐가는 경우
- 점화식 : `D[a][b] = MIN ( D[a][b] , d[a][k]+ d[k][b])` / DP방식
- 인접행렬(2차원 배열) 사용
- 루프문 3개 돌린다. / K값을 사용하기 위해서
- 갱신을 하기에 음의 가중치 있어도 사용 가능

5. 벨만 포드

- **특정한 노드**에서 출발하여 다른 모든 노드로 가는 최단 경로 계산
- 매번 모든 간선을 전부 확인 / 다익스트라는 한번 방문한 노드는 확인하지 않는다는 점이 다르다
- 음의 순환을 탐지할 수 있다.

### 투포인터

- 시작점과 끝점을 정해서 접근하는 경우
- 리스트 내에서 부분합, 연속적인 값들이 조건에 맞는 경우를 뽑기 위한 방법

### 누적합

- 특정 구간의 모든 수를 합한 값을 계산
- 미리 누적합을 구해놓고 특정 구간의 합을 빠르게 구하기 위해 사용

### 최소신장트리

- 그래프 내 모든 정점을 포함하는 트리
- Kruskal , Prim
